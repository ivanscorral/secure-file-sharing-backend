<"file: package.json">{"name": "secure-file-sharing-backend","version": "0.0.1","description": "The back-end of the Secure File Sharing Platform handles file upload, encryption, storage, decryption, download, and expiration. It provides a secure and efficient means for temporary and anonymous file sharing.","main": "index.js","scripts": {"start": "node src/index.ts","start-ts": "npx ts-node src/index.ts","test": "echo \"Error: no test specified\" && exit 1"},"keywords": ["secure"],"author": "Ivan Sanchez Corral","license": "MIT","dependencies": {"@typegoose/typegoose": "^11.4.1","cors": "^2.8.5","dotenv": "^16.3.1","express": "^4.18.2","mongoose": "^7.4.4","nanoid": "^4.0.2","prettier": "^3.0.2"},"devDependencies": {"@types/mongoose": "^5.11.97","@typescript-eslint/eslint-plugin": "^6.5.0","@typescript-eslint/parser": "^6.5.0","eslint": "^8.47.0","eslint-config-standard": "^17.1.0","eslint-plugin-import": "^2.28.1","eslint-plugin-n": "^16.0.2","eslint-plugin-promise": "^6.1.1","typescript": "^5.2.2"}}</"file: package.json">

<"file: src/controllers/fileController.ts">import FileMetadataRepository from '../repositories/fileMetadataRepository'import FileService from '../services/fileService'import FileMetadataModel from '../models/fileMetadataModel'import { randomBytes } from 'crypto'// Upload File: Handles file upload and encryptionexports.uploadFile = (req, res, next) => {// TODO: Implement file upload logicres.status(200).send('File upload endpoint')}// Download File: Retrieve and decrypt the fileexports.downloadFile = (req, res, next) => {// TODO: Implement file download logicres.status(200).send('File download endpoint')}// Get File Status: Check file metadata or status (optional)exports.getFileStatus = (req, res, next) => {// TODO: Implement file status check logicres.status(200).send('File status endpoint')}exports.testStoreMetadata = async (req, res, next) => {// initialize repository and service with metadata modelconst fileMetadataRepository: FileMetadataRepository = new FileMetadataRepository(FileMetadataModel)const fileService: FileService = new FileService(fileMetadataRepository)// create a mock metadata object with a unique IDconst id = randomBytes(8).toString('hex')const metadata = {id: uniqueId,filePath: 'test.txt',encryptionKey: 'encryptionKey',expirationTime: new Date(),downloadCount: 0,maxDownloads: 0,createdAt: new Date(),status: 'available'}// store metadataconst result = await fileService.createFile(metadata)res.status(200).send('Request result: ' + result)}</"file: src/controllers/fileController.ts">

<"file: src/index.ts">import express from 'express'import cors from 'cors'import mongoose from 'mongoose'import crypto from 'crypto'import dotenv from 'dotenv'dotenv.config()// Needed for mocking purposesimport FileMetadataRepository from './repositories/fileMetadataRepository'import FileService from './services/fileService'// Create the mock objects to test the fileServiceconst fileService = new FileService(new FileMetadataRepository({}))// Constantsconst app = express()const PORT = process.env.PORT || 3000const MONGO_URI = process.env.MONGO_URI || 'mongodb://localhost:27017/secure-file-sharing'// Middlewareapp.use(express.json())app.use(cors())// Routesimport fileRoutes from './routes/fileRoutes'app.use('/api/files', fileRoutes)app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {console.error(err.stack)res.status(500).json({ message: 'Something went wrong!' })})app.listen(PORT, () => {console.log(`Server is listening on port ${PORT}`)})async function encryptionDemo (buffer: Buffer) {// High-resolution timingconst start = process.hrtime.bigint()const encryptedCfg = await fileService.encrypt(buffer)const end = process.hrtime.bigint()console.log(`Time taken: ${(end - start) / 1000000n} ms to encrypt with size ${buffer.length}`)console.log(encryptedCfg)// Decryption code commented out}/*** Generates a random buffer of the specified length.** @param {number} length - The length of the buffer to be generated.* @return {Buffer} - A buffer containing random bytes.*/function createRandomBuffer (length: number): Buffer {return crypto.randomBytes(length)}// Execute the function with 1MB of bufferencryptionDemo(createRandomBuffer(1024 * 1024 * 500)).catch((err) => {console.error('An error occurred:', err)})if (!process.env.DISABLE_DB) {console.log('Connecting to MongoDB...')mongoose.connect(MONGO_URI, {useNewUrlParser: true,useUnifiedTopology: true}).then(() => {console.log('Connected to MongoDB')}).catch((err) => {console.error('An error occurred connecting to mongoDB:', err)})}export default app</"file: src/index.ts">

<"file: src/models/fileMetadataModel.ts">import mongoose from 'mongoose'import { prop, getModelForClass } from '@typegoose/typegoose'import { nanoid } from 'nanoid'//Interfaces@modelOptions({schemaOptions: { timestamps: true }})interface FileMetadataProps {id: stringfilePath: stringkey: Bufferiv: BufferexpiresAt: DatedownloadCount?: numbermaxDownloadCount: number}class FileMetadata {@prop({ required: true, unique: true, index: true, default: () => nanoid(10)})public id!: string;@prop({ required: true })public filePath!: string;@prop({ required: true })public key!: Buffer;@prop({ required: true })public iv!: Buffer;@prop({ required: true })public expiresAt!: Date;@prop({ default: 0 })public downloadCount?: number;@prop(default: 0)public maxDownloadCount!: number;}export const FileMetadataModel = getModelForClass(FileMetadata)</"file: src/models/fileMetadataModel.ts">

<"file: src/repositories/baseRepository.js">class BaseRepository {constructor (model) {this.model = model}async create (data) {return this.model.create(data)}async findById (id) {return this.model.findById(id)}async updateById (id, data) {return this.model.findByIdAndUpdate(id, data, { new: true })}async deleteById (id) {return this.model.findByIdAndDelete(id)}}module.exports = BaseRepository</"file: src/repositories/baseRepository.js">

<"file: src/repositories/fileMetadataRepository.js">const BaseRepository = require('./baseRepository')class FileMetadataRepository extends BaseRepository {async getFileName (id) {const fullPath = await this.model.findById(id).select('filePath')return fullPath.filePath}async isFileAvailable (id) {const isAvailable = await this.model.findById(id).select('status')return isAvailable.status}}module.exports = FileMetadataRepository</"file: src/repositories/fileMetadataRepository.js">

<"file: src/routes/fileRoutes.ts">import express from 'express'import fileController from '../controllers/fileController'import { Router } from 'express'const router: Router = express.Router()// Upload Endpoint: Handle file upload and encryptionrouter.post('/upload', fileController.uploadFile)// Download Endpoint: Retrieve and decrypt the filerouter.get('/download/:id', fileController.downloadFile)// Optional: Status Endpoint to check file metadata or statusrouter.get('/status/:id', fileController.getFileStatus)router.get('/testStoreMetadata', fileController.testStoreMetadata)export default router</"file: src/routes/fileRoutes.ts">

<"file: src/services/cryptoService.js">/*** @class CryptoService* @construct* @param {Object} options - The configuration options for the service.* @method encrypt - Encrypts a data buffer using the configured encryption mode.* @method decrypt - Decrypts a data buffer using the configured encryption mode.* @method setEncryptionAlgorithm - Sets the encryption algorithm in the configuration.*  @param {String} algorithm - The encryption algorithm to use.* @method getAvailableEncryptionAlgorithms - Returns a list of available encryption algorithms from OpenSSL.* @property {Object} options - The configuration options for the service.**//*** @typedef {Object} CryptoOptions* @property {String} algorithm - The encryption algorithm to use.* @property {Buffer} iv - The initialization vector.* @property {Buffer} key - The encryption key.*/const crypto = require('crypto')class CryptoService {/*** @constructor* @param {CryptoOptions} options - The configuration options for the service.*/constructor (options = {algorithm: 'aes-256-cbc',iv: crypto.randomBytes(16),key: crypto.randomBytes(32)}) {this.options = options}}</"file: src/services/cryptoService.js">

<"file: src/services/fileService.ts">import crypto from 'crypto'e/*** Service class for handling file-related operations.*/class FileService {/*** @param {Object} fileMetadataRepository - The repository for interacting with file metadata.*/constructor (fileMetadataRepository) {this.fileMetadataRepository = fileMetadataRepository}/*** Create a new file record.* @param {FileMetadata} metadata - The file metadata object.*/async createFile (metadata) {// TODO Implement file creation logicconsole.log('Creating file with metadata: ', metadata)return this.fileMetadataRepository.create(metadata)}/*** Delete a file record by ID.* @param {string} id - The file ID.*/async deleteFile (id) {// TODO Implement file deletion logic}/*** Increment the download count of a file.* @param {string} id - The file ID.*/async incrementDownloadCount (id) {// TODO Implement file download logic}/*** Handle file expiration logic.* @param {string} id - The file ID.*/async handleFileExpiration (id) {// TODO Implement file expiration logic}/*** Encrypts a data buffer using AES-256 in CBC mode.* @param {Buffer} data - The data buffer to encrypt.* @returns {Promise<Object>} The iv, key, and encrypted buffers as a JSON object.*/async encrypt (data) {const iv = crypto.randomBytes(16)const key = crypto.randomBytes(32)const cipher = crypto.createCipheriv('aes-256-cbc', key, iv)const encrypted = Buffer.concat([cipher.update(data), cipher.final()])return { iv, key, data: encrypted }}/*** Decrypt a data buffer using AES-256 in CBC mode.* @param {Buffer} data - The data buffer to decrypt.* @param {Buffer} iv - The initialization vector.* @param {Buffer} key - The encryption key.* @returns {Promise<Buffer>} - The decrypted data.*/async decrypt (data, iv, key) {const crypto = require('crypto')const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv)let decryptedData = decipher.update(data)decryptedData = Buffer.concat([decryptedData, decipher.final()])return decryptedData}}module.exports = FileService</"file: src/services/fileService.ts">
